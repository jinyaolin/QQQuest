# QQQuest 開發日記

> 記錄 QQQuest 專案的完整開發歷程、功能實現、問題修復和技術決策

**專案名稱**: QQQuest - Quest 設備同步管理系統  
**開始日期**: 2025-11-XX  
**當前版本**: v0.3.0  
**最後更新**: 2025-12-02

---

## 📋 目錄

- [版本歷史](#版本歷史)
- [核心功能開發](#核心功能開發)
- [技術架構演進](#技術架構演進)
- [問題修復記錄](#問題修復記錄)
- [性能優化](#性能優化)
- [UI/UX 改進](#uiux-改進)
- [重要決策](#重要決策)

---

## 版本歷史

### v0.3.0 - 2025-12-02

#### ✨ 新增功能

**🏠 房間管理（完整實現）**
- 房間 CRUD 操作（創建、編輯、刪除）
- 設備分組管理（添加/移除設備）
- 智能設備轉移（自動從舊房間移出）
- 房間容量管理（最大設備數量限制）
- 房間視圖（點擊房間名稱查看所有設備）
- 批量執行動作（針對房間內所有設備）
- 房間重新連接功能（並發處理）

**⚡ 動作管理（完整實現）**
- 6 種動作類型：
  1. ☀️ 喚醒設備
  2. 😴 休眠設備
  3. 🔌 保持喚醒（接電源時不進入深度睡眠）
  4. 🚀 執行程式
  5. 🛑 關閉程式
  6. 🔄 重啟應用
  7. ⌨️ 發送按鍵
- 動作參數驗證
- 執行統計（次數、成功率）
- 動作複製功能
- 搜索和篩選

**🔧 設備管理改進**
- 設備排序功能（向上/向下移動）
- 設備狀態重新定義（ONLINE/OFFLINE/NOT_CONNECTED）
- 移除序號顯示（使用 WiFi ADB，序號即 IP:Port）
- 設備卡片優化（統一高度、對齊）

#### 🔧 技術改進

**並發處理優化**
- 實現 `execute_action_batch()` - 批量並發執行動作
- 實現 `get_status_batch()` - 批量並發獲取狀態
- 實現 `connect_batch()` - 批量並發連接設備
- 使用 `ThreadPoolExecutor` 進行並發處理
- 大幅提升批量操作性能（10 台設備從 150 秒降至 15 秒）

**資料持久化**
- 設備資料按 `sort_order` 排序保存
- 實現 `reorder_devices()` 方法
- JSON 文件按順序排列，便於閱讀

**核心模組**
- `core/room.py` - 房間資料模型
- `core/room_registry.py` - 房間管理
- `core/action.py` - 動作資料模型
- `core/action_registry.py` - 動作管理
- `utils/init.py` - 系統初始化工具

#### 🐛 Bug 修復

- 修復設備狀態同步問題（離線設備狀態正確保存）
- 修復房間重新連接順序阻塞問題（改為並發處理）
- 修復設備排序按鈕對齊問題
- 修復對話框關閉按鈕導致空白頁面問題
- 修復動作類型選擇不即時響應問題
- 修復頁面刷新後系統未初始化問題

---

### v0.2.0 - 2025-12-01

#### ✨ 新增功能

**⚡ 動作管理**
- 6 種動作類型完整實現
- 動作參數驗證和格式檢查
- 執行統計和歷史記錄
- 動作搜索和篩選

**🔧 ADB 擴展**
- `execute_wake_up()` - 喚醒設備
- `execute_sleep()` - 休眠設備
- `execute_launch_app()` - 啟動應用
- `execute_stop_app()` - 關閉應用
- `execute_restart_app()` - 重啟應用
- `execute_send_key()` - 發送按鍵

#### 📊 程式碼統計
- 新增程式碼：約 1,627 行
- 新增檔案：3 個
- 修改檔案：2 個

---

### v0.1.0 - 2025-12-01 (MVP Release)

#### ✨ 核心功能

**📱 設備管理**
- 手動添加設備（IP + Port）
- 設備列表顯示（響應式卡片佈局）
- 設備資訊編輯（代號、名稱、備註）
- 設備移除功能
- 自動狀態同步（在線/離線）
- 設備詳細狀態監控：
  - 電池電量和充電狀態
  - 設備溫度
  - 運作時間（uptime）
  - 清醒/休眠狀態

**📺 設備監看**
- scrcpy 實時監看
- 低延遲（< 50ms）
- 高幀率（60fps）
- 完整鍵鼠控制
- 自訂視窗標題
- 預設禁用音訊轉發

**⚙️ 系統設定**
- scrcpy 參數設定（12+ 個選項）
- 截圖預覽參數設定
- 設定匯入/匯出（JSON）
- 重置為預設值

#### 🐛 Bug 修復

- 修復 scrcpy 音訊問題（添加 `--no-audio`）
- 修復對話框關閉按鈕問題
- 修復設備狀態超時問題
- 修復資料庫重複資料問題
- 修復 JSON 序列化錯誤

#### 🔧 技術架構

- 使用 Pydantic 進行資料驗證
- 使用 TinyDB 進行輕量級資料持久化
- 使用 Loguru 實現結構化日誌
- 實現設定分層（系統預設 + 使用者自訂）

---

## 核心功能開發

### 設備管理系統

#### 設備狀態定義演進

**v0.1.0**: 簡單的在線/離線狀態
- `ONLINE` - 設備在線
- `OFFLINE` - 設備離線

**v0.3.0**: 精確的狀態定義
- `ONLINE` - 在 `adb devices` 列表中，且 `state == "device"`
- `OFFLINE` - 在 `adb devices` 列表中，但 `state == "offline"`
- `NOT_CONNECTED` - 不在 `adb devices` 列表中

**實現細節**：
- 根據 ADB 實際 `state` 字段判斷
- 自動狀態同步和更新
- 狀態圖標和顏色區分

#### 設備排序功能

**需求**: 用戶可以自定義設備顯示順序

**實現**:
- 添加 `sort_order` 字段到 Device 模型
- 實現向上/向下移動按鈕
- 自動分配 `sort_order`（如果缺失）
- JSON 文件按 `sort_order` 排序保存

**技術細節**:
- 使用 `sort_order` 整數值排序
- 移動時交換相鄰設備的 `sort_order`
- 保存後重新排序 JSON 文件

### 房間管理系統

#### 設計決策

**房間屬性**:
- `name` - 房間名稱
- `description` - 房間說明
- `max_devices` - 最大設備數量（0 = 無限制）
- `device_ids` - 設備 ID 列表

**智能設備轉移**:
- 無需確認，但清楚標注設備當前所在房間
- 勾選已在其他房間的設備 = 自動轉移
- 取消勾選已在此房間的設備 = 移出房間

**容量管理**:
- 設定最大設備數量
- 顯示容量：「3/5 台」或「3 台（無限制）」
- 超過容量時自動阻止

#### 房間視圖功能

**實現**:
- 點擊房間名稱進入房間視圖
- 顯示房間內所有設備卡片
- 支持所有設備管理功能
- 使用標籤頁分隔不同狀態的設備

### 動作管理系統

#### 動作類型

1. **喚醒設備** (`WAKE_UP`)
   - 喚醒休眠中的設備
   - 可選驗證喚醒成功

2. **休眠設備** (`SLEEP`)
   - 讓設備進入休眠
   - 可選強制休眠（使用 SLEEP 鍵）

3. **保持喚醒** (`KEEP_AWAKE`) - v0.3.0 新增
   - 設置設備在接電源時不進入深度睡眠
   - 支持 4 種模式（0-3）
   - 使用 `settings put global stay_on_while_plugged_in` 命令

4. **執行程式** (`LAUNCH_APP`)
   - 啟動指定應用（package + activity）
   - 可選停止已運行的實例
   - 可選等待啟動完成

5. **關閉程式** (`STOP_APP`)
   - 強制停止應用
   - 支持 `force-stop` 和 `kill` 兩種方式

6. **重啟應用** (`RESTART_APP`)
   - 關閉後重新啟動應用
   - 可設定重啟延遲

7. **發送按鍵** (`SEND_KEY`)
   - 發送任意按鍵事件
   - 支持常用按鍵快速選擇

#### 參數驗證

- Package 名稱格式驗證（正則表達式）
- Activity 名稱格式驗證
- Keycode 驗證
- Mode 參數驗證（0-3）

---

## 技術架構演進

### 並發處理優化

#### 問題分析

**原始實現**（v0.1.0）:
```python
# 順序執行，阻塞式
for device in devices:
    result = execute_command(device)  # 阻塞 15 秒
```

**問題**:
- 10 台設備需要 150 秒（15 秒 × 10）
- 無響應設備會阻塞整個流程
- 用戶體驗差

#### 解決方案（v0.3.0）

**並發處理**:
```python
# 使用 ThreadPoolExecutor 並發執行
with ThreadPoolExecutor(max_workers=10) as executor:
    futures = {executor.submit(task, device): device for device in devices}
    for future in as_completed(futures):
        result = future.result()
```

**性能提升**:
- 10 台設備從 150 秒降至 15 秒（10 倍提升）
- 無響應設備不阻塞其他設備
- 支持進度回調

**實現的方法**:
- `execute_action_batch()` - 批量執行動作
- `get_status_batch()` - 批量獲取狀態
- `connect_batch()` - 批量連接設備

### 資料持久化

#### TinyDB 使用

**優點**:
- 輕量級，無需額外服務
- JSON 格式，易於閱讀和調試
- 簡單的 API

**挑戰**:
- 不保證 JSON 文件順序
- 需要手動排序和重新寫入

**解決方案**:
- 實現 `reorder_devices()` 方法
- 保存時重新排序 JSON 文件
- 確保文件按 `sort_order` 排列

### 狀態管理

#### Session State 管理

**問題**: 頁面刷新後 session state 丟失

**解決方案**:
- 實現 `utils/init.py` 初始化工具
- 所有頁面統一調用 `ensure_initialization()`
- 自動重新初始化核心組件

---

## 問題修復記錄

### 設備狀態同步問題

**問題**: 離線設備狀態未正確保存到資料庫

**原因**: 只有在線設備的詳細狀態被保存，離線設備狀態被忽略

**修復**: 在狀態同步邏輯中，明確保存離線設備狀態

### 對話框關閉按鈕問題

**問題**: 點擊對話框右上角 X 按鈕會導致空白頁面

**原因**: Streamlit 的 `st.dialog` 預設有關閉按鈕，但關閉時未更新 session state

**修復**: 使用 CSS 隱藏關閉按鈕，強制使用取消按鈕

### 動作類型選擇不響應問題

**問題**: 在 `st.form` 中選擇動作類型時，參數輸入不即時更新

**原因**: `st.form` 會阻止即時更新

**修復**: 移除 `st.form` 包裝，使用普通輸入控件

### 並發處理阻塞問題

**問題**: 房間重新連接時，順序執行導致長時間阻塞

**原因**: 使用 `for` 循環順序執行，無響應設備會阻塞

**修復**: 實現 `connect_batch()` 方法，使用並發處理

---

## 性能優化

### 批量操作優化

**優化前**:
- 10 台設備執行動作：150 秒
- 10 台設備獲取狀態：150 秒
- 10 台設備重新連接：150 秒

**優化後**:
- 10 台設備執行動作：15 秒（10 倍提升）
- 10 台設備獲取狀態：15 秒（10 倍提升）
- 10 台設備重新連接：15 秒（10 倍提升）

### 狀態查詢優化

**優化前**: 每個設備單獨查詢（多次 ADB 命令）

**優化後**: 批量查詢（單一 ADB 命令獲取所有狀態）

### 資料庫查詢優化

**優化**: 使用索引和緩存減少資料庫查詢次數

---

## UI/UX 改進

### 設備卡片優化

**v0.1.0**:
- 卡片高度不一致
- 底部內容不對齊
- 顯示設備型號（導致高度不一致）

**v0.3.0**:
- 統一卡片高度（`min-height: 380px`）
- 底部內容對齊
- 移除設備型號顯示
- 移除序號顯示（使用連接信息）

### 排序按鈕優化

**v0.3.0**:
- 合併向上/向下按鈕到單一容器
- 縮小按鈕尺寸（1/2）
- 減少按鈕間距
- 居中對齊

### 房間卡片優化

**v0.3.0**:
- 增加卡片寬度（每行 2 個）
- 增加標題列寬度（5:1）
- 允許按鈕文本換行
- 移除"台"單位

### 對話框優化

**改進**:
- 隱藏右上角 X 按鈕
- 統一使用取消按鈕
- 確保狀態正確更新

---

## 重要決策

### 1. 移除 USB 自動偵測

**決策**: 移除 USB 自動偵測功能，僅支持手動添加

**原因**:
- 簡化系統架構
- 減少依賴和複雜度
- WiFi ADB 更穩定

### 2. 使用 TinyDB 而非 SQLite

**決策**: 使用 TinyDB 進行資料持久化

**原因**:
- 輕量級，無需額外服務
- JSON 格式，易於調試
- 簡單的 API

### 3. 並發處理而非異步

**決策**: 使用 `ThreadPoolExecutor` 而非 `asyncio`

**原因**:
- ADB 命令是同步的
- 線程池更簡單直接
- 性能提升明顯

### 4. 設備狀態重新定義

**決策**: 精確定義三種連接狀態

**原因**:
- 更準確反映 ADB 連接狀態
- 提供正確的操作建議
- 改善用戶體驗

---

## 開發工具和流程

### 使用的工具

- **Python 3.9+**
- **Streamlit** - Web 應用框架
- **Pydantic** - 資料驗證
- **TinyDB** - 資料持久化
- **Loguru** - 日誌工具
- **ThreadPoolExecutor** - 並發處理

### 開發流程

1. **需求分析** - 明確功能需求
2. **設計** - 設計資料模型和 API
3. **實現** - 編寫程式碼
4. **測試** - 功能測試和性能測試
5. **優化** - 性能優化和 UI 改進
6. **文檔** - 更新文檔和日記

---

## 未來計劃

### v0.4.0 (計劃中)

- [ ] 時間碼同步功能
- [ ] CUE 排程系統
- [ ] 設備搜尋和過濾
- [ ] 批量操作改進
- [ ] 統計報表

### 長期目標

- [ ] 多用戶支持
- [ ] 遠程訪問
- [ ] 設備分組策略
- [ ] 自動化腳本
- [ ] API 接口

---

**最後更新**: 2025-12-02  
**維護者**: QQQuest Team  
**版本**: v0.3.0


